include('zepto', "/* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */\n;(function(undefined){\n  if (String.prototype.trim === undefined) // fix for iOS 3.2\n    String.prototype.trim = function(){ return this.replace(/^\\s+/, '').replace(/\\s+$/, '') }\n\n  // For iOS 3.x\n  // from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce\n  if (Array.prototype.reduce === undefined)\n    Array.prototype.reduce = function(fun){\n      if(this === void 0 || this === null) throw new TypeError()\n      var t = Object(this), len = t.length >>> 0, k = 0, accumulator\n      if(typeof fun != 'function') throw new TypeError()\n      if(len == 0 && arguments.length == 1) throw new TypeError()\n\n      if(arguments.length >= 2)\n       accumulator = arguments[1]\n      else\n        do{\n          if(k in t){\n            accumulator = t[k++]\n            break\n          }\n          if(++k >= len) throw new TypeError()\n        } while (true)\n\n      while (k < len){\n        if(k in t) accumulator = fun.call(undefined, accumulator, t[k], k, t)\n        k++\n      }\n      return accumulator\n    }\n\n})()\nvar Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    getComputedStyle = document.defaultView.getComputedStyle,\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n\n    // Used by `$.zepto.init` to wrap elements, text/comment nodes, document,\n    // and document fragment node types.\n    elementTypes = [1, 3, 8, 9, 11],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    classSelectorRE = /^\\.([\\w-]+)$/,\n    idSelectorRE = /^#([\\w-]+)$/,\n    tagSelectorRE = /^[\\w-]+$/,\n    toString = ({}).toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div')\n\n  zepto.matches = function(element, selector) {\n    if (!element || element.nodeType !== 1) return false\n    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector ||\n                          element.oMatchesSelector || element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function isFunction(value) { return toString.call(value) == \"[object Function]\" }\n  function isObject(value) { return value instanceof Object }\n  function isPlainObject(value) {\n    var key, ctor\n    if (toString.call(value) !== \"[object Object]\") return false\n    ctor = (isFunction(value.constructor) && value.constructor.prototype)\n    if (!ctor || !hasOwnProperty.call(ctor, 'isPrototypeOf')) return false\n    for (key in value);\n    return key === undefined || hasOwnProperty.call(value, key)\n  }\n  function isArray(value) { return value instanceof Array }\n  function likeArray(obj) { return typeof obj.length == 'number' }\n\n  function compact(array) { return array.filter(function(item){ return item !== undefined && item !== null }) }\n  function flatten(array) { return array.length > 0 ? [].concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return array.filter(function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overriden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name) {\n    if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n    if (!(name in containers)) name = '*'\n    var container = containers[name]\n    container.innerHTML = '' + html\n    return $.each(slice.call(container.childNodes), function(){\n      container.removeChild(this)\n    })\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. Note that `__proto__` is not supported on Internet\n  // Explorer. This method can be overriden in plugins.\n  zepto.Z = function(dom, selector) {\n    dom = dom || []\n    dom.__proto__ = arguments.callee.prototype\n    dom.selector = selector || ''\n    return dom\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overriden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overriden in plugins.\n  zepto.init = function(selector, context) {\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, juts return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      var dom\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // if a JavaScript object is given, return a copy of it\n      // this is a somewhat peculiar option, but supported by\n      // jQuery so we'll do it, too\n      else if (isPlainObject(selector))\n        dom = [$.extend({}, selector)], selector = null\n      // wrap stuff like `document` or `window`\n      else if (elementTypes.indexOf(selector.nodeType) >= 0 || selector === window)\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n      // create a new Zepto collection from the nodes found\n      return zepto.Z(dom, selector)\n    }\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, whichs makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    slice.call(arguments, 1).forEach(function(source) {\n      for (key in source)\n        if (source[key] !== undefined)\n          target[key] = source[key]\n    })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overriden in plugins.\n  zepto.qsa = function(element, selector){\n    var found\n    return (element === document && idSelectorRE.test(selector)) ?\n      ( (found = element.getElementById(RegExp.$1)) ? [found] : emptyArray ) :\n      (element.nodeType !== 1 && element.nodeType !== 9) ? emptyArray :\n      slice.call(\n        classSelectorRE.test(selector) ? element.getElementsByClassName(RegExp.$1) :\n        tagSelectorRE.test(selector) ? element.getElementsByTagName(selector) :\n        element.querySelectorAll(selector)\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector === undefined ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  function funcArg(context, arg, idx, payload) {\n   return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  $.isFunction = isFunction\n  $.isObject = isObject\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.trim = function(str) { return str.trim() }\n\n  // plugin compatibility\n  $.uuid = 0\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    indexOf: emptyArray.indexOf,\n    concat: emptyArray.concat,\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $.map(this, function(el, i){ return fn.call(el, i, el) })\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      if (readyRE.test(document.readyState)) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      this.forEach(function(el, idx){ callback.call(el, idx, el) })\n      return this\n    },\n    filter: function(selector){\n      return $([].filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result\n      if (this.length == 1) result = zepto.qsa(this[0], selector)\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return $(result)\n    },\n    closest: function(selector, context){\n      var node = this[0]\n      while (node && !zepto.matches(node, selector))\n        node = node !== context && node !== document && node.parentNode\n      return $(node)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && node !== document && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return slice.call(this.children) }), selector)\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return slice.call(el.parentNode.children).filter(function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return this.map(function(){ return this[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = null)\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(newContent){\n      return this.each(function(){\n        $(this).wrapAll($(newContent)[0].cloneNode(false))\n      })\n    },\n    wrapAll: function(newContent){\n      if (this[0]) {\n        $(this[0]).before(newContent = $(newContent))\n        newContent.append(this)\n      }\n      return this\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return $(this.map(function(){ return this.cloneNode(true) }))\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return (setting === undefined ? this.css(\"display\") == \"none\" : setting) ? this.show() : this.hide()\n    },\n    prev: function(){ return $(this.pluck('previousElementSibling')) },\n    next: function(){ return $(this.pluck('nextElementSibling')) },\n    html: function(html){\n      return html === undefined ?\n        (this.length > 0 ? this[0].innerHTML : null) :\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        })\n    },\n    text: function(text){\n      return text === undefined ?\n        (this.length > 0 ? this[0].textContent : null) :\n        this.each(function(){ this.textContent = text })\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && value === undefined) ?\n        (this.length == 0 || this[0].nodeType !== 1 ? undefined :\n          (name == 'value' && this[0].nodeName == 'INPUT') ? this.val() :\n          (!(result = this[0].getAttribute(name)) && name in this[0]) ? this[0][name] : result\n        ) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) this.setAttribute(key, name[key])\n          else this.setAttribute(name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ if (this.nodeType === 1) this.removeAttribute(name) })\n    },\n    prop: function(name, value){\n      return (value === undefined) ?\n        (this[0] ? this[0][name] : undefined) :\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        })\n    },\n    data: function(name, value){\n      var data = this.attr('data-' + dasherize(name), value)\n      return data !== null ? data : undefined\n    },\n    val: function(value){\n      return (value === undefined) ?\n        (this.length > 0 ? this[0].value : undefined) :\n        this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n    },\n    offset: function(){\n      if (this.length==0) return null\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: obj.width,\n        height: obj.height\n      }\n    },\n    css: function(property, value){\n      if (value === undefined && typeof property == 'string')\n        return (\n          this.length == 0\n            ? undefined\n            : this[0].style[camelize(property)] || getComputedStyle(this[0], '').getPropertyValue(property))\n\n      var css = ''\n      for (key in property)\n        if(typeof property[key] == 'string' && property[key] == '')\n          this.each(function(){ this.style.removeProperty(dasherize(key)) })\n        else\n          css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n\n      if (typeof property == 'string')\n        if (value == '')\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (this.length < 1) return false\n      else return classRE(name).test(this[0].className)\n    },\n    addClass: function(name){\n      return this.each(function(idx){\n        classList = []\n        var cls = this.className, newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && (this.className += (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (name === undefined)\n          return this.className = ''\n        classList = this.className\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        this.className = classList.trim()\n      })\n    },\n    toggleClass: function(name, when){\n      return this.each(function(idx){\n        var newName = funcArg(this, name, idx, this.className)\n        ;(when === undefined ? !$(this).hasClass(newName) : when) ?\n          $(this).addClass(newName) : $(this).removeClass(newName)\n      })\n    }\n  }\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    $.fn[dimension] = function(value){\n      var offset, Dimension = dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n      if (value === undefined) return this[0] == window ? window['inner' + Dimension] :\n        this[0] == document ? document.documentElement['offset' + Dimension] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        var el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function insert(operator, target, node) {\n    var parent = (operator % 2) ? target : target.parentNode\n    parent ? parent.insertBefore(node,\n      !operator ? target.nextSibling :      // after\n      operator == 1 ? parent.firstChild :   // prepend\n      operator == 2 ? target :              // before\n      null) :                               // append\n      $(node).remove()\n  }\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var key in node.childNodes) traverseNode(node.childNodes[key], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(key, operator) {\n    $.fn[key] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var nodes = $.map(arguments, function(n){ return isObject(n) ? n : zepto.fragment(n) })\n      if (nodes.length < 1) return this\n      var size = this.length, copyByClone = size > 1, inReverse = operator < 2\n\n      return this.each(function(index, target){\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[inReverse ? nodes.length-i-1 : i]\n          traverseNode(node, function(node){\n            if (node.nodeName != null && node.nodeName.toUpperCase() === 'SCRIPT' && (!node.type || node.type === 'text/javascript'))\n              window['eval'].call(window, node.innerHTML)\n          })\n          if (copyByClone && index < size - 1) node = node.cloneNode(true)\n          insert(operator, target, node)\n        }\n      })\n    }\n\n    $.fn[(operator % 2) ? key+'To' : 'insert'+(operator ? 'Before' : 'After')] = function(html){\n      $(html)[key](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.camelize = camelize\n  zepto.uniq = uniq\n  $.zepto = zepto\n\n  return $\n})()\n\n// If `$` is not yet defined, point it to `Zepto`\nwindow.Zepto = Zepto\n'$' in window || (window.$ = Zepto)\n;(function($){\n  var $$ = $.zepto.qsa, handlers = {}, _zid = 1, specialEvents={}\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eachEvent(events, fn, iterator){\n    if ($.isObject(events)) $.each(events, iterator)\n    else events.split(/\\s/).forEach(function(type){ iterator(type, fn) })\n  }\n\n  function add(element, events, fn, selector, getDelegate, capture){\n    capture = !!capture\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    eachEvent(events, fn, function(event, fn){\n      var delegate = getDelegate && getDelegate(fn, event),\n        callback = delegate || fn\n      var proxyfn = function (event) {\n        var result = callback.apply(element, [event].concat(event.data))\n        if (result === false) event.preventDefault()\n        return result\n      }\n      var handler = $.extend(parse(event), {fn: fn, proxy: proxyfn, sel: selector, del: delegate, i: set.length})\n      set.push(handler)\n      element.addEventListener(handler.e, proxyfn, capture)\n    })\n  }\n  function remove(element, events, fn, selector){\n    var id = zid(element)\n    eachEvent(events || '', fn, function(event, fn){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n        element.removeEventListener(handler.e, handler.proxy, false)\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    if ($.isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (typeof context == 'string') {\n      return $.proxy(fn[context], fn)\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, callback){\n    return this.each(function(){\n      add(this, event, callback)\n    })\n  }\n  $.fn.unbind = function(event, callback){\n    return this.each(function(){\n      remove(this, event, callback)\n    })\n  }\n  $.fn.one = function(event, callback){\n    return this.each(function(i, element){\n      add(this, event, callback, null, function(fn, type){\n        return function(){\n          var result = fn.apply(element, arguments)\n          remove(element, type, fn)\n          return result\n        }\n      })\n    })\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n  function createProxy(event) {\n    var proxy = $.extend({originalEvent: event}, event)\n    $.each(eventMethods, function(name, predicate) {\n      proxy[name] = function(){\n        this[predicate] = returnTrue\n        return event[name].apply(event, arguments)\n      }\n      proxy[predicate] = returnFalse\n    })\n    return proxy\n  }\n\n  // emulates the 'defaultPrevented' property for browsers that have none\n  function fix(event) {\n    if (!('defaultPrevented' in event)) {\n      event.defaultPrevented = false\n      var prevent = event.preventDefault\n      event.preventDefault = function() {\n        this.defaultPrevented = true\n        prevent.call(this)\n      }\n    }\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    var capture = false\n    if(event == 'blur' || event == 'focus'){\n      if($.iswebkit)\n        event = event == 'blur' ? 'focusout' : event == 'focus' ? 'focusin' : event\n      else\n        capture = true\n    }\n\n    return this.each(function(i, element){\n      add(element, event, callback, selector, function(fn){\n        return function(e){\n          var evt, match = $(e.target).closest(selector, element).get(0)\n          if (match) {\n            evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n            return fn.apply(match, [evt].concat([].slice.call(arguments, 1)))\n          }\n        }\n      }, capture)\n    })\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, callback){\n    return selector == undefined || $.isFunction(selector) ?\n      this.bind(event, selector) : this.delegate(selector, event, callback)\n  }\n  $.fn.off = function(event, selector, callback){\n    return selector == undefined || $.isFunction(selector) ?\n      this.unbind(event, selector) : this.undelegate(selector, event, callback)\n  }\n\n  $.fn.trigger = function(event, data){\n    if (typeof event == 'string') event = $.Event(event)\n    fix(event)\n    event.data = data\n    return this.each(function(){\n      // items in the collection might not be DOM elements\n      // (todo: possibly support events on plain old objects)\n      if('dispatchEvent' in this) this.dispatchEvent(event)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, data){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(typeof event == 'string' ? $.Event(event) : event)\n      e.data = data\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback){ return this.bind(event, callback) }\n  })\n\n  ;['focus', 'blur'].forEach(function(name) {\n    $.fn[name] = function(callback) {\n      if (callback) this.bind(name, callback)\n      else if (this.length) try { this.get(0)[name]() } catch(e){}\n      return this\n    }\n  })\n\n  $.Event = function(type, props) {\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true, null, null, null, null, null, null, null, null, null, null, null, null)\n    return event\n  }\n\n})(Zepto)\n;(function($){\n  function detect(ua){\n    var os = this.os = {}, browser = this.browser = {},\n      webkit = ua.match(/WebKit\\/([\\d.]+)/),\n      android = ua.match(/(Android)\\s+([\\d.]+)/),\n      ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/),\n      iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/),\n      webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/),\n      touchpad = webos && ua.match(/TouchPad/),\n      kindle = ua.match(/Kindle\\/([\\d.]+)/),\n      silk = ua.match(/Silk\\/([\\d._]+)/),\n      blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/)\n\n    // todo clean this up with a better OS/browser\n    // separation. we need to discern between multiple\n    // browsers on android, and decide if kindle fire in\n    // silk mode is android or not\n\n    if (browser.webkit = !!webkit) browser.version = webkit[1]\n\n    if (android) os.android = true, os.version = android[2]\n    if (iphone) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.')\n    if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.')\n    if (webos) os.webos = true, os.version = webos[2]\n    if (touchpad) os.touchpad = true\n    if (blackberry) os.blackberry = true, os.version = blackberry[2]\n    if (kindle) os.kindle = true, os.version = kindle[1]\n    if (silk) browser.silk = true, browser.version = silk[1]\n    if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true\n  }\n\n  detect.call($, navigator.userAgent)\n  // make available to unit tests\n  $.__detect = detect\n\n})(Zepto)\n;(function($, undefined){\n  var prefix = '', eventPrefix, endEventName, endAnimationName,\n    vendors = { Webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' },\n    document = window.document, testEl = document.createElement('div'),\n    supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\n    clearProperties = {}\n\n  function downcase(str) { return str.toLowerCase() }\n  function normalizeEvent(name) { return eventPrefix ? eventPrefix + name : downcase(name) }\n\n  $.each(vendors, function(vendor, event){\n    if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {\n      prefix = '-' + downcase(vendor) + '-'\n      eventPrefix = event\n      return false\n    }\n  })\n\n  clearProperties[prefix + 'transition-property'] =\n  clearProperties[prefix + 'transition-duration'] =\n  clearProperties[prefix + 'transition-timing-function'] =\n  clearProperties[prefix + 'animation-name'] =\n  clearProperties[prefix + 'animation-duration'] = ''\n\n  $.fx = {\n    off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined),\n    cssPrefix: prefix,\n    transitionEnd: normalizeEvent('TransitionEnd'),\n    animationEnd: normalizeEvent('AnimationEnd')\n  }\n\n  $.fn.animate = function(properties, duration, ease, callback){\n    if ($.isObject(duration))\n      ease = duration.easing, callback = duration.complete, duration = duration.duration\n    if (duration) duration = duration / 1000\n    return this.anim(properties, duration, ease, callback)\n  }\n\n  $.fn.anim = function(properties, duration, ease, callback){\n    var transforms, cssProperties = {}, key, that = this, wrappedCallback, endEvent = $.fx.transitionEnd\n    if (duration === undefined) duration = 0.4\n    if ($.fx.off) duration = 0\n\n    if (typeof properties == 'string') {\n      // keyframe animation\n      cssProperties[prefix + 'animation-name'] = properties\n      cssProperties[prefix + 'animation-duration'] = duration + 's'\n      endEvent = $.fx.animationEnd\n    } else {\n      // CSS transitions\n      for (key in properties)\n        if (supportedTransforms.test(key)) {\n          transforms || (transforms = [])\n          transforms.push(key + '(' + properties[key] + ')')\n        }\n        else cssProperties[key] = properties[key]\n\n      if (transforms) cssProperties[prefix + 'transform'] = transforms.join(' ')\n      if (!$.fx.off && typeof properties === 'object') {\n        cssProperties[prefix + 'transition-property'] = Object.keys(properties).join(', ')\n        cssProperties[prefix + 'transition-duration'] = duration + 's'\n        cssProperties[prefix + 'transition-timing-function'] = (ease || 'linear')\n      }\n    }\n\n    wrappedCallback = function(event){\n      if (typeof event !== 'undefined') {\n        if (event.target !== event.currentTarget) return // makes sure the event didn't bubble from \"below\"\n        $(event.target).unbind(endEvent, arguments.callee)\n      }\n      $(this).css(clearProperties)\n      callback && callback.call(this)\n    }\n    if (duration > 0) this.bind(endEvent, wrappedCallback)\n\n    setTimeout(function() {\n      that.css(cssProperties)\n      if (duration <= 0) setTimeout(function() {\n        that.each(function(){ wrappedCallback.call(this) })\n      }, 0)\n    }, 0)\n\n    return this\n  }\n\n  testEl = null\n})(Zepto)\n;(function($){\n  var jsonpID = 0,\n      isObject = $.isObject,\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.defaultPrevented\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options){\n    var callbackName = options.callback || 'jsonp' + (++jsonpID),\n      script = document.createElement('script'),\n      abort = function(){\n        $(script).remove()\n        if (callbackName in window) window[callbackName] = empty\n        ajaxComplete('abort', xhr, options)\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (options.error) script.onerror = function() {\n      xhr.abort()\n      options.error()\n    }\n\n    window[callbackName] = function(data){\n      clearTimeout(abortTimeout)\n      $(script).remove()\n      delete window[callbackName]\n      ajaxSuccess(data, xhr, options)\n    }\n\n    serializeData(options)\n    script.src = options.url.replace(/=\\?/, '=' + callbackName)\n    $('head').append(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.abort()\n        ajaxComplete('timeout', xhr, options)\n      }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    accepts: {\n      script: 'text/javascript, application/javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0\n  }\n\n  function mimeToDataType(mime) {\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (isObject(options.data)) options.data = $.param(options.data)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET'))\n      options.url = appendQuery(options.url, options.data)\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {})\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) settings.crossDomain = /^([\\w-]+:)?\\/\\/([^\\/]+)/.test(settings.url) &&\n      RegExp.$2 != window.location.host\n\n    var dataType = settings.dataType, hasPlaceholder = /=\\?/.test(settings.url)\n    if (dataType == 'jsonp' || hasPlaceholder) {\n      if (!hasPlaceholder) settings.url = appendQuery(settings.url, 'callback=?')\n      return $.ajaxJSONP(settings)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    serializeData(settings)\n\n    var mime = settings.accepts[dataType],\n        baseHeaders = { },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = $.ajaxSettings.xhr(), abortTimeout\n\n    if (!settings.crossDomain) baseHeaders['X-Requested-With'] = 'XMLHttpRequest'\n    if (mime) {\n      baseHeaders['Accept'] = mime\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.data && settings.type.toUpperCase() != 'GET'))\n      baseHeaders['Content-Type'] = (settings.contentType || 'application/x-www-form-urlencoded')\n    settings.headers = $.extend(baseHeaders, settings.headers || {})\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(xhr.getResponseHeader('content-type'))\n          result = xhr.responseText\n\n          try {\n            if (dataType == 'script')    (1,eval)(result)\n            else if (dataType == 'xml')  result = xhr.responseXML\n            else if (dataType == 'json') result = blankRE.test(result) ? null : JSON.parse(result)\n          } catch (e) { error = e }\n\n          if (error) ajaxError(error, 'parsererror', xhr, settings)\n          else ajaxSuccess(result, xhr, settings)\n        } else {\n          ajaxError(null, 'error', xhr, settings)\n        }\n      }\n    }\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async)\n\n    for (name in settings.headers) xhr.setRequestHeader(name, settings.headers[name])\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      return false\n    }\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  $.get = function(url, success){ return $.ajax({ url: url, success: success }) }\n\n  $.post = function(url, data, success, dataType){\n    if ($.isFunction(data)) dataType = dataType || success, success = data, data = null\n    return $.ajax({ type: 'POST', url: url, data: data, success: success, dataType: dataType })\n  }\n\n  $.getJSON = function(url, success){\n    return $.ajax({ url: url, success: success, dataType: 'json' })\n  }\n\n  $.fn.load = function(url, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector\n    if (parts.length > 1) url = parts[0], selector = parts[1]\n    $.get(url, function(response){\n      self.html(selector ?\n        $(document.createElement('div')).html(response.replace(rscript, \"\")).find(selector).html()\n        : response)\n      success && success.call(self)\n    })\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var array = $.isArray(obj)\n    $.each(obj, function(key, value) {\n      if (scope) key = traditional ? scope : scope + '[' + (array ? '' : key) + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (traditional ? $.isArray(value) : isObject(value))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(k, v){ this.push(escape(k) + '=' + escape(v)) }\n    serialize(params, obj, traditional)\n    return params.join('&').replace('%20', '+')\n  }\n})(Zepto)\n;(function ($) {\n  $.fn.serializeArray = function () {\n    var result = [], el\n    $( Array.prototype.slice.call(this.get(0).elements) ).each(function () {\n      el = $(this)\n      var type = el.attr('type')\n      if (this.nodeName.toLowerCase() != 'fieldset' &&\n        !this.disabled && type != 'submit' && type != 'reset' && type != 'button' &&\n        ((type != 'radio' && type != 'checkbox') || this.checked))\n        result.push({\n          name: el.attr('name'),\n          value: el.val()\n        })\n    })\n    return result\n  }\n\n  $.fn.serialize = function () {\n    var result = []\n    this.serializeArray().forEach(function (elm) {\n      result.push( encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value) )\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function (callback) {\n    if (callback) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.defaultPrevented) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n;(function($){\n  var touch = {}, touchTimeout\n\n  function parentIfText(node){\n    return 'tagName' in node ? node : node.parentNode\n  }\n\n  function swipeDirection(x1, x2, y1, y2){\n    var xDelta = Math.abs(x1 - x2), yDelta = Math.abs(y1 - y2)\n    return xDelta >= yDelta ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down')\n  }\n\n  var longTapDelay = 750, longTapTimeout\n\n  function longTap(){\n    longTapTimeout = null\n    if (touch.last) {\n      touch.el.trigger('longTap')\n      touch = {}\n    }\n  }\n\n  function cancelLongTap(){\n    if (longTapTimeout) clearTimeout(longTapTimeout)\n    longTapTimeout = null\n  }\n\n  $(document).ready(function(){\n    var now, delta\n\n    $(document.body).bind('touchstart', function(e){\n      now = Date.now()\n      delta = now - (touch.last || now)\n      touch.el = $(parentIfText(e.touches[0].target))\n      touchTimeout && clearTimeout(touchTimeout)\n      touch.x1 = e.touches[0].pageX\n      touch.y1 = e.touches[0].pageY\n      if (delta > 0 && delta <= 250) touch.isDoubleTap = true\n      touch.last = now\n      longTapTimeout = setTimeout(longTap, longTapDelay)\n    }).bind('touchmove', function(e){\n      cancelLongTap()\n      touch.x2 = e.touches[0].pageX\n      touch.y2 = e.touches[0].pageY\n    }).bind('touchend', function(e){\n       cancelLongTap()\n\n      // double tap (tapped twice within 250ms)\n      if (touch.isDoubleTap) {\n        touch.el.trigger('doubleTap')\n        touch = {}\n\n      // swipe\n      } else if ((touch.x2 && Math.abs(touch.x1 - touch.x2) > 30) ||\n                 (touch.y2 && Math.abs(touch.y1 - touch.y2) > 30)) {\n        touch.el.trigger('swipe') &&\n          touch.el.trigger('swipe' + (swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2)))\n        touch = {}\n\n      // normal tap\n      } else if ('last' in touch) {\n        touch.el.trigger('tap')\n\n        touchTimeout = setTimeout(function(){\n          touchTimeout = null\n          touch.el.trigger('singleTap')\n          touch = {}\n        }, 250)\n      }\n    }).bind('touchcancel', function(){\n      if (touchTimeout) clearTimeout(touchTimeout)\n      if (longTapTimeout) clearTimeout(longTapTimeout)\n      longTapTimeout = touchTimeout = null\n      touch = {}\n    })\n  })\n\n  ;['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function(m){\n    $.fn[m] = function(callback){ return this.bind(m, callback) }\n  })\n})(Zepto)\n");
